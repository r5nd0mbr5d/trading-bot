# Trading Bot — Python Style Guide

**Scope:** All production code (`src/`, `backtest/`, `research/`), tests (`tests/`), and scripts.  
**Base Standard:** [PEP 8](https://www.python.org/dev/peps/pep-0008/) + [PEP 20 (Zen of Python)](https://www.python.org/dev/peps/pep-0020/)  
**Enforcement:** `black`, `pycodestyle`, `pylint`, `pre-commit` (see `pyproject.toml`, `.pylintrc`, `.pre-commit-config.yaml`)

---

## 1. General Principles

### Explicit > Implicit
- Function signatures must be **clear and unambiguous**. Avoid `*args` / `**kwargs` unless absolutely necessary.
- Example (Bad): `def fetch(*args)` — what are the args?
- Example (Good): `def fetch(symbol: str, period: str = '1d') -> pd.DataFrame` — caller knows exactly what to pass.

### One Statement Per Line
- No compound statements: `if x: return y`
- No multiple assignments on one line: `a, b = 1, 2` is OK; `a = 1; b = 2` is not.

### Readability Counts
- Code is read far more often than written.
- Prefer clarity over brevity.
- Comments explain **why**, not what (the code shows what).

### Single Exit Point (Generally)
- Prefer **early returns** for error cases.
- Aim for **one normal exit** (one place where you return the main result).
- Example:
  ```python
  def process_signal(signal: Signal) -> Optional[Order]:
      if not signal:
          return None  # Early return
      if signal.strength < 0.5:
          return None  # Early return
      # Main logic here
      order = create_order(signal)
      return order  # Single main exit
  ```

### Private Conventions
- Prefix internal methods/properties with `_` underscore (e.g., `_validate_bar()`, `_cache_path`).
- Double underscore (`__`) only for name-mangling; avoid in this codebase.
- Single trailing underscore for reserved names: `class_` instead of `class`.

---

## 2. Naming Conventions

| Category | Style | Example |
|----------|-------|---------|
| **Modules/Files** | `snake_case` | `market_data_store.py` |
| **Classes** | `PascalCase` | `MarketDataStore`, `AlpacaBroker` |
| **Functions/Methods** | `snake_case` | `fetch_historical()`, `approve_signal()` |
| **Module Constants** | `UPPER_SNAKE_CASE` | `DEFAULT_LOOKBACK_PERIOD`, `MAX_POSITION_SIZE` |
| **Private Methods** | `_snake_case` | `_validate_bar()`, `_parse_csv()` |
| **Private Attributes** | `_snake_case` | `self._cache`, `self._retries` |

---

## 3. Function Signatures & Documentation

### Type Hints (Required)
All public functions must have type hints:
```python
def fetch_historical(
    symbol: str,
    start_date: str,
    end_date: str,
    interval: str = '1d'
) -> pd.DataFrame:
    """
    Fetch OHLCV bars from market data provider.
    
    Args:
        symbol: Ticker symbol (e.g., 'AAPL').
        start_date: ISO format start date (e.g., '2024-01-01').
        end_date: ISO format end date.
        interval: Bar interval ('1d', '1h', '5m'). Defaults to '1d'.
    
    Returns:
        DataFrame with columns [Open, High, Low, Close, Volume], 
        UTC index, sorted ascending.
    
    Raises:
        ProviderError: If symbol not found or data unavailable.
        ValueError: If start_date >= end_date.
    """
```

### Docstring Style (NumPy-style)
- **One-liner summary** on first line, followed by blank line.
- **Args:** Describe each parameter and type.
- **Returns:** Describe return value and type.
- **Raises:** List exceptions raised and when.
- **Example (optional):** For complex functions.

---

## 4. Project-Specific Conventions

### Timestamps: UTC-Aware Always
All timestamps must be timezone-aware (UTC):
```python
# Good
import pandas as pd
df.index = pd.to_datetime(df.index, utc=True)

# Bad
df.index = pd.to_datetime(df.index)  # Naive datetime
```

### Strategy Inheritance Pattern
All strategies must subclass `BaseStrategy`:
```python
from src.strategies.base import BaseStrategy

class MyStrategy(BaseStrategy):
    def generate_signal(self, symbol: str) -> Optional[Signal]:
        """Generate signal for symbol. Return None if insufficient data."""
        if len(self.df) < self.min_bars_required():
            return None
        # ... logic ...
        return Signal(...)
    
    def min_bars_required(self) -> int:
        return 20  # Longest lookback period
```

### Data Provider Pattern
All providers must inherit from `BaseProvider` and implement:
```python
class MyProvider(BaseProvider):
    def fetch_historical(
        self, symbol: str, start_date: str, end_date: str, interval: str
    ) -> pd.DataFrame:
        """Fetch bars. Raise ProviderError on failure."""
        # ... implementation ...
    
    def _validate_response(self, data: dict) -> bool:
        """Private validation helper."""
        # ...
```

### Error Handling
- **Explicit exceptions** — raise specific error types (`ProviderError`, `SignalError`, `RiskError`).
- **Never silent failures** — log before returning None or raising.
- **Fallback patterns** — catch provider errors, try next provider, log warning.

### Risk Manager Gate
`RiskManager.approve_signal()` is the **ONLY path** from Signal to Order. Never submit orders directly from strategies.

---

## 5. Code Structure & Organization

### Imports
- **Standard library imports** first (blank line)
- **Third-party imports** second (blank line)
- **Local imports** third
- Use absolute imports: `from src.strategies.base import BaseStrategy` (not relative)
- Avoid wildcard imports: `from module import *`

```python
# Good
import json
from typing import Optional

import pandas as pd
import numpy as np

from src.data.models import Signal, Bar
from src.risk.manager import RiskManager
```

### File Organization
1. Module docstring
2. Imports
3. Module-level constants
4. Classes (in dependency order)
5. Functions
6. Main guard: `if __name__ == '__main__'`

### Line Length
- **Maximum: 100 characters** (configured in `black` and `.editorconfig`)
- For long lines, use implicit continuation (parentheses), not backslashes:
  ```python
  # Good
  result = calculate(
      parameter_one, parameter_two, parameter_three
  )
  
  # Bad
  result = calculate(parameter_one, parameter_two, \
                     parameter_three)
  ```

---

## 6. Testing Conventions

### Test Naming
- Test files: `test_<module>.py`
- Test functions: `test_<functionality>_<expected_outcome>`
- Fixtures: Use `conftest.py` for shared fixtures

```python
def test_fetch_historical_returns_dataframe_with_correct_columns():
    """Specific, testable assertion."""
    df = provider.fetch_historical('AAPL', '2024-01-01', '2024-01-05')
    assert isinstance(df, pd.DataFrame)
    assert list(df.columns) == ['Open', 'High', 'Low', 'Close', 'Volume']
```

### Assertions
- Use explicit assertions: `assert x == y, "message"` (not implicit truthy checks)
- One assertion per line (when possible)
- Use pytest idioms: `pytest.raises()`, `pytest.mark.parametrize()`

### Mocking
- Mock at the boundary (e.g., mock `urlopen`, not the entire provider)
- Patch early, before instantiation
- Use descriptive mock return values

```python
@patch('src.data.providers.urlopen')
def test_provider_handles_timeout(mock_urlopen):
    mock_urlopen.side_effect = urllib.error.URLError('Timeout')
    with pytest.raises(ProviderError):
        provider.fetch_historical('AAPL', '2024-01-01', '2024-01-05')
```

---

## 7. Pythonic Idioms

### Looping & Iteration
- Use `enumerate()` instead of `range(len())`:
  ```python
  # Good
  for i, bar in enumerate(bars):
      print(i, bar.close)

  # Bad
  for i in range(len(bars)):
      print(i, bars[i].close)
  ```

- Use `with` for file handling (auto-closes):
  ```python
  with open('data.csv') as f:
      data = f.read()
  ```

### List Comprehensions vs Generators
- Use comprehensions when you need a list multiple times
- Use generators when iterating once (memory efficient)
  ```python
  # Comprehension: allocates full list
  result = [x * 2 for x in large_list if x > 100]
  for item in result:
      process(item)
  for item in result:  # Iterate again
      process(item)

  # Generator: lazy evaluation
  result = (x * 2 for x in large_list if x > 100)
  for item in result:
      process(item)
  ```

### Membership Tests
- Use `in` for sets/dicts (O(1) lookup)
- Use `in` for lists only if small or one-time
  ```python
  # Good
  symbols = {'AAPL', 'MSFT', 'NVDA'}
  if 'AAPL' in symbols:
      process()

  # Bad (O(n) lookup)
  symbols = ['AAPL', 'MSFT', 'NVDA']
  if 'AAPL' in symbols:
      process()
  ```

### Unpacking
- Use tuple unpacking for readability:
  ```python
  # Good
  open_price, close_price = bar.open, bar.close

  # Also good
  a, *middle, z = [1, 2, 3, 4, 5]  # a=1, middle=[2,3,4], z=5
  ```

### Dictionary Access
- Use `.get()` with default:
  ```python
  # Good
  value = config.get('key', 'default')

  # Acceptable
  if 'key' in config:
      value = config['key']
  ```

### Throwaway Variables
- Use `_` (single underscore) for variables whose value is deliberately unused:
  ```python
  # Good — signal clearly that the loop index is not needed
  for _ in range(retries):
      attempt_connection()

  # Good — unpacking where only some values are needed
  symbol, _, close_price = parse_bar_line(line)
  ```
- Do **not** use `__` (double underscore) for throwaway variables — reserve that for name-mangling.

### String Building
- Use `''.join()` for assembling strings from a list — never concatenate in a loop:
  ```python
  # Good — single allocation
  report = '\n'.join(lines)

  # Bad — O(n²) allocations
  report = ''
  for line in lines:
      report += line + '\n'
  ```

### Boolean Testing
- Test truthiness directly; never compare to `True`, `False`, or `None` with `==`:
  ```python
  # Good
  if signal:
      process(signal)
  if df is None:
      return
  if not errors:
      commit()

  # Bad
  if signal == True:
      process(signal)
  if df == None:
      return
  ```

---

## 8. Avoid "Magic" / Complex Patterns

### Prohibited (Unless Exceptional Reason + Comments)
- `__getattr__`, `__setattr__` (implicit attribute magic)
- Custom metaclasses
- Monkey-patching built-ins
- `eval()`, `exec()`
- Deep recursion (use loops instead)

### Acceptable (With Documentation)
- Context managers (`__enter__`, `__exit__`)
- Descriptors (`@property`, `@staticmethod`)
- Decorators (with docstring explaining purpose)
- `*args` / `**kwargs` only if documented and necessary

---

## 9. Comments & Documentation

### Docstrings vs Block Comments — the Distinction
The Hitchhiker's Guide draws a specific line:
- **Docstrings** explain **how to use** code (public API contract — what to pass, what comes back, what can go wrong).
- **Block comments** explain **why** the code is doing what it does (implementation intent, non-obvious decisions).

```python
def approve_signal(self, signal: Signal) -> Optional[Order]:
    """
    Gate a signal through all risk checks and return an Order if approved.

    Args:
        signal: Candidate signal from a strategy.

    Returns:
        Order if signal passes all risk gates, None otherwise.
    """
    # Skip position check during market open auction — fills are unreliable
    # in the first 5 minutes (LSE-specific behaviour observed Feb 2026)
    if self._is_auction_window():
        return None
```

### Bad Comments (Avoid)
```python
i += 1  # Increment i
```

### Good Comments (Explain Why)
```python
# Skip first row; it contains headers
i = 1
```

### Inline Comments: Sparingly
```python
# Good: explains non-obvious decision
cutoff = 5 * self.atr  # 5x ATR as dynamic stop, based on Chandelier strategy

# Bad: obvious
x = 10  # Set x to 10
```

### Module & Class Docstrings: Required
```python
"""
Market data storage and retrieval layer.

Provides persistent SQLite cache + optional Parquet snapshots
to avoid redundant provider calls and improve latency.
"""
```

---

## 10. Common Python Gotchas

> Source: [Hitchhiker's Guide — Common Gotchas](https://python-docs.readthedocs.io/en/latest/writing/gotchas.html)

These are silent bugs that behave correctly in simple tests but fail in production use.

### Mutable Default Arguments

**The problem:** Default argument values are evaluated **once at function definition**, not on each call. A mutable default (list, dict, set) is shared across all invocations.

```python
# BAD — 'to' is created once and reused across all calls
def append_to(element, to=[]):
    to.append(element)
    return to

append_to(1)  # [1]
append_to(2)  # [1, 2]  ← NOT [2] as expected
```

```python
# GOOD — use None as sentinel; create fresh object inside function
def append_to(element, to=None):
    if to is None:
        to = []
    to.append(element)
    return to
```

**In this codebase:** Any function that takes a default `list`, `dict`, or `set` parameter must use `None` as the default.

---

### Late Binding Closures

**The problem:** Closures capture **variable names**, not values. The value is looked up at the time the inner function is **called**, not when it was defined. In loops, all closures end up referencing the loop variable's final value.

```python
# BAD — all lambdas return 4 * x (the final value of i)
multipliers = [lambda x: i * x for i in range(5)]
print(multipliers[0](2))  # 8, not 0
print(multipliers[2](2))  # 8, not 4
```

```python
# GOOD — capture the current value via default argument
multipliers = [lambda x, i=i: i * x for i in range(5)]
print(multipliers[0](2))  # 0
print(multipliers[2](2))  # 4
```

**In this codebase:** The `on_bar` callback in `main.py` is a closure that captures `settings`, `broker`, `strategy`, and other loop-level objects. This is a known architectural risk (see Step 37 refactor). When writing new closures or callback factories, capture values explicitly via default arguments or class attributes — never rely on a shared mutable variable from an outer scope.

---

### Bytecode Files (`.pyc`)

Python auto-generates `__pycache__/` directories. These are already excluded via `.gitignore`. Do not commit them.

---

## 11. Architecture Anti-Patterns

> Source: [Hitchhiker's Guide — Structuring Your Project](https://python-docs.readthedocs.io/en/latest/writing/structure.html)

Recognise these by name. They all appear in real codebases and are the target of Steps 37–43.

| Anti-Pattern | Description | Example in This Project |
|---|---|---|
| **Circular dependencies** | Module A imports B, B imports A — resolved via fragile hacks | Risk if strategies import from main |
| **Hidden coupling** | Changing one module silently breaks an unrelated one | 18 test files importing from `main.py` |
| **Global state abuse** | Modules share implicit mutable state rather than passing arguments | Module-level `app` objects in pairs-ibkr style code |
| **Spaghetti code** | Deeply nested conditionals, copy-pasted logic, no clear flow | `on_bar` closure in `main.py` (280 lines, 5-level nesting) |
| **Ravioli code** | Hundreds of tiny disconnected objects with no coherent structure | Over-splitting into micro-modules with no clear ownership |

### Rules to avoid them

- **No circular imports.** If two modules need each other, extract the shared contract to a third module (usually a dataclass or protocol in `src/data/models.py`).
- **No module-level mutable state.** Pass objects explicitly through constructors and function arguments.
- **Keep `__init__.py` minimal.** Empty or a single-line docstring. Do not put logic in `__init__.py`.
- **Module names:** short, lowercase, no special characters, no dots. Use subpackages for namespacing (`src.execution.resilience` not `src.execution_resilience`).

---

## 12. Functional Design — Pure Functions and Stateless Logic

> Source: [Hitchhiker's Guide — Structuring Your Project](https://python-docs.readthedocs.io/en/latest/writing/structure.html)

**OOP is not mandatory in Python.** Before writing a class, ask whether a module of pure functions would be simpler.

### Prefer pure functions where possible

A **pure function** has no side effects and returns the same output for the same input every time. Pure functions are:
- Trivially testable (no setup, no mocks needed)
- Safe to call in parallel
- Easy to reason about and refactor

```python
# Pure — same inputs always produce same output; no side effects
def calculate_position_size(
    signal_strength: float,
    available_capital: float,
    max_position_fraction: float,
) -> float:
    return available_capital * max_position_fraction * signal_strength


# Impure — reads from self, modifies self._portfolio
def approve_signal(self, signal: Signal) -> Optional[Order]:
    if self._portfolio.drawdown > self._max_drawdown:
        return None
    ...
```

**OOP is appropriate when:**
- The object has meaningful long-lived state (e.g., `IBKRBroker` manages a persistent connection)
- The object coordinates multiple resources (e.g., `RiskManager` gates multiple concurrent signals)
- You need polymorphism (e.g., `BaseStrategy` → `MACrossoverStrategy`)

**Use plain functions when:**
- The operation is a transformation: data in → data out (feed normalisation, indicator calculation, report generation)
- There is no state to maintain across calls
- The function is called from one place and never needs to be subclassed

```python
# Good — pure transformation; no class needed
def normalise_ohlcv(df: pd.DataFrame, provider: str) -> pd.DataFrame:
    """Normalise column names and ensure UTC-aware index."""
    df = df.rename(columns=PROVIDER_COLUMN_MAP[provider])
    df.index = pd.to_datetime(df.index, utc=True)
    return df.sort_index()
```

### Avoid reusing variable names for different types

Python's dynamic typing makes this especially dangerous:

```python
# BAD — 'result' changes type mid-function; confusing and error-prone
result = fetch_bars(symbol)      # DataFrame
result = result['Close'].values  # ndarray
result = float(result[-1])       # float

# GOOD — distinct names, clear types throughout
bars_df = fetch_bars(symbol)
close_prices = bars_df['Close'].values
latest_close = float(close_prices[-1])
```

---

## 13. Testing — Extended Guidance

> Source: [Hitchhiker's Guide — Testing Your Code](https://python-docs.readthedocs.io/en/latest/writing/tests.html)

This extends §6 with additional tooling and patterns.

### Core principle (Hitchhiker's Guide)

> "A testing unit should focus on one tiny bit of functionality and prove it correct."

- Tests must be **independent** — one test's pass/fail must not affect another's
- Tests must be **fast** — slow tests get skipped; fast tests get run
- Tests must be **deterministic** — same result every time on the same machine

### Property-Based Testing with Hypothesis

For functions with complex input spaces, property-based testing generates hundreds of random inputs automatically. Use `hypothesis` for numerical calculations, data transformations, and risk calculations.

```python
from hypothesis import given, strategies as st
from src.risk.manager import calculate_position_size

@given(
    strength=st.floats(min_value=0.0, max_value=1.0),
    capital=st.floats(min_value=0.0, max_value=1_000_000),
)
def test_position_size_never_exceeds_capital(strength, capital):
    size = calculate_position_size(strength, capital, max_fraction=0.1)
    assert size <= capital * 0.1
    assert size >= 0.0
```

Install: `pip install hypothesis`

### Doctest — Inline Examples as Tests

For simple utility functions, embed usage examples directly in the docstring and run them as tests:

```python
def to_pips(price_diff: float, pip_size: float = 0.0001) -> float:
    """
    Convert a price difference to pips.

    >>> to_pips(0.0050)
    50.0
    >>> to_pips(0.0001)
    1.0
    """
    return price_diff / pip_size
```

Run with: `pytest --doctest-modules src/`

Use sparingly — only for pure utility functions where the example *is* the documentation.

### Test organisation reminder

```
tests/
  conftest.py          # Shared fixtures (Settings, mock brokers, sample DataFrames)
  test_<module>.py     # One test file per source module
```

- Keep `conftest.py` fixtures minimal; prefer local fixtures for test-specific setup
- Never import from `main.py` in tests — import from the actual source module being tested

---

## 14. Enforcement & Automation

### Local Checks (Pre-Commit)
```bash
pre-commit install  # Set up hooks in .git/hooks
git commit -m "message"  # Hooks run auto-checks
```

### Manual Checks
```bash
# Auto-format
black src/ tests/ backtest/

# Check (don't modify)
black --check src/ tests/

# Lint
pylint src/ tests/

# Style violations
pycodestyle src/ tests/

# Type checking (optional, requires stubs)
mypy src/

# Property-based tests (if hypothesis installed)
pytest tests/ --hypothesis-seed=0
```

### In CI/CD
- Run `black --check` (fail if unformatted)
- Run `pylint` with score threshold
- Run `pytest` with coverage

---

## 15. Refactoring Checklist

Before submitting a PR or marking a task complete:

- [ ] All tests pass (`pytest tests/`)
- [ ] Code is formatted (`black --check src/`)
- [ ] No lint violations (`pylint src/ --fail-under=8`)
- [ ] Type hints on all public functions
- [ ] Docstrings on all public classes/functions
- [ ] No hardcoded symbols/dates (use `config/settings.py`)
- [ ] Error messages are clear and actionable
- [ ] Private methods/attributes prefixed with `_`
- [ ] Timestamps are UTC-aware
- [ ] No "magic" without documentation
- [ ] No mutable default arguments (use `None` sentinel)
- [ ] No closures capturing mutable outer-scope state (see §10 Late Binding)
- [ ] No circular imports introduced
- [ ] Pure functions preferred where no state is needed (see §12)
- [ ] Variable names not reused for different types within a function

---

## 16. For LLMs Working in This Codebase

**This guide is auto-loaded by:** `CLAUDE.md` (session context)

**Tools enforce this on commit:**
- Automatic fixes: `black` (formatting)
- Warnings: `pylint`, `pycodestyle` (style, metrics)
- Cannot commit until resolved (pre-commit hook)

**For new code:** Write to this standard from the start. It's faster than refactoring later.

**Questions?** Check the relevant section above or the tool configs:
- `pyproject.toml` — Black line length, pytest paths
- `.pylintrc` — Linting rules, score thresholds
- `.pre-commit-config.yaml` — Hooks that run on commit
- `CLAUDE.md` — Session context reference

---

**Last Updated:** February 24, 2026
**Version:** 1.1 — expanded with Hitchhiker's Guide design concepts
