# Trading Bot — Python Style Guide

**Scope:** All production code (`src/`, `backtest/`, `research/`), tests (`tests/`), and scripts.  
**Base Standard:** [PEP 8](https://www.python.org/dev/peps/pep-0008/) + [PEP 20 (Zen of Python)](https://www.python.org/dev/peps/pep-0020/)  
**Enforcement:** `black`, `pycodestyle`, `pylint`, `pre-commit` (see `pyproject.toml`, `.pylintrc`, `.pre-commit-config.yaml`)

---

## 1. General Principles

### Explicit > Implicit
- Function signatures must be **clear and unambiguous**. Avoid `*args` / `**kwargs` unless absolutely necessary.
- Example (Bad): `def fetch(*args)` — what are the args?
- Example (Good): `def fetch(symbol: str, period: str = '1d') -> pd.DataFrame` — caller knows exactly what to pass.

### One Statement Per Line
- No compound statements: `if x: return y`
- No multiple assignments on one line: `a, b = 1, 2` is OK; `a = 1; b = 2` is not.

### Readability Counts
- Code is read far more often than written.
- Prefer clarity over brevity.
- Comments explain **why**, not what (the code shows what).

### Single Exit Point (Generally)
- Prefer **early returns** for error cases.
- Aim for **one normal exit** (one place where you return the main result).
- Example:
  ```python
  def process_signal(signal: Signal) -> Optional[Order]:
      if not signal:
          return None  # Early return
      if signal.strength < 0.5:
          return None  # Early return
      # Main logic here
      order = create_order(signal)
      return order  # Single main exit
  ```

### Private Conventions
- Prefix internal methods/properties with `_` underscore (e.g., `_validate_bar()`, `_cache_path`).
- Double underscore (`__`) only for name-mangling; avoid in this codebase.
- Single trailing underscore for reserved names: `class_` instead of `class`.

---

## 2. Naming Conventions

| Category | Style | Example |
|----------|-------|---------|
| **Modules/Files** | `snake_case` | `market_data_store.py` |
| **Classes** | `PascalCase` | `MarketDataStore`, `AlpacaBroker` |
| **Functions/Methods** | `snake_case` | `fetch_historical()`, `approve_signal()` |
| **Module Constants** | `UPPER_SNAKE_CASE` | `DEFAULT_LOOKBACK_PERIOD`, `MAX_POSITION_SIZE` |
| **Private Methods** | `_snake_case` | `_validate_bar()`, `_parse_csv()` |
| **Private Attributes** | `_snake_case` | `self._cache`, `self._retries` |

---

## 3. Function Signatures & Documentation

### Type Hints (Required)
All public functions must have type hints:
```python
def fetch_historical(
    symbol: str,
    start_date: str,
    end_date: str,
    interval: str = '1d'
) -> pd.DataFrame:
    """
    Fetch OHLCV bars from market data provider.
    
    Args:
        symbol: Ticker symbol (e.g., 'AAPL').
        start_date: ISO format start date (e.g., '2024-01-01').
        end_date: ISO format end date.
        interval: Bar interval ('1d', '1h', '5m'). Defaults to '1d'.
    
    Returns:
        DataFrame with columns [Open, High, Low, Close, Volume], 
        UTC index, sorted ascending.
    
    Raises:
        ProviderError: If symbol not found or data unavailable.
        ValueError: If start_date >= end_date.
    """
```

### Docstring Style (NumPy-style)
- **One-liner summary** on first line, followed by blank line.
- **Args:** Describe each parameter and type.
- **Returns:** Describe return value and type.
- **Raises:** List exceptions raised and when.
- **Example (optional):** For complex functions.

---

## 4. Project-Specific Conventions

### Timestamps: UTC-Aware Always
All timestamps must be timezone-aware (UTC):
```python
# Good
import pandas as pd
df.index = pd.to_datetime(df.index, utc=True)

# Bad
df.index = pd.to_datetime(df.index)  # Naive datetime
```

### Strategy Inheritance Pattern
All strategies must subclass `BaseStrategy`:
```python
from src.strategies.base import BaseStrategy

class MyStrategy(BaseStrategy):
    def generate_signal(self, symbol: str) -> Optional[Signal]:
        """Generate signal for symbol. Return None if insufficient data."""
        if len(self.df) < self.min_bars_required():
            return None
        # ... logic ...
        return Signal(...)
    
    def min_bars_required(self) -> int:
        return 20  # Longest lookback period
```

### Data Provider Pattern
All providers must inherit from `BaseProvider` and implement:
```python
class MyProvider(BaseProvider):
    def fetch_historical(
        self, symbol: str, start_date: str, end_date: str, interval: str
    ) -> pd.DataFrame:
        """Fetch bars. Raise ProviderError on failure."""
        # ... implementation ...
    
    def _validate_response(self, data: dict) -> bool:
        """Private validation helper."""
        # ...
```

### Error Handling
- **Explicit exceptions** — raise specific error types (`ProviderError`, `SignalError`, `RiskError`).
- **Never silent failures** — log before returning None or raising.
- **Fallback patterns** — catch provider errors, try next provider, log warning.

### Risk Manager Gate
`RiskManager.approve_signal()` is the **ONLY path** from Signal to Order. Never submit orders directly from strategies.

---

## 5. Code Structure & Organization

### Imports
- **Standard library imports** first (blank line)
- **Third-party imports** second (blank line)
- **Local imports** third
- Use absolute imports: `from src.strategies.base import BaseStrategy` (not relative)
- Avoid wildcard imports: `from module import *`

```python
# Good
import json
from typing import Optional

import pandas as pd
import numpy as np

from src.data.models import Signal, Bar
from src.risk.manager import RiskManager
```

### File Organization
1. Module docstring
2. Imports
3. Module-level constants
4. Classes (in dependency order)
5. Functions
6. Main guard: `if __name__ == '__main__'`

### Line Length
- **Maximum: 100 characters** (configured in `black` and `.editorconfig`)
- For long lines, use implicit continuation (parentheses), not backslashes:
  ```python
  # Good
  result = calculate(
      parameter_one, parameter_two, parameter_three
  )
  
  # Bad
  result = calculate(parameter_one, parameter_two, \
                     parameter_three)
  ```

---

## 6. Testing Conventions

### Test Naming
- Test files: `test_<module>.py`
- Test functions: `test_<functionality>_<expected_outcome>`
- Fixtures: Use `conftest.py` for shared fixtures

```python
def test_fetch_historical_returns_dataframe_with_correct_columns():
    """Specific, testable assertion."""
    df = provider.fetch_historical('AAPL', '2024-01-01', '2024-01-05')
    assert isinstance(df, pd.DataFrame)
    assert list(df.columns) == ['Open', 'High', 'Low', 'Close', 'Volume']
```

### Assertions
- Use explicit assertions: `assert x == y, "message"` (not implicit truthy checks)
- One assertion per line (when possible)
- Use pytest idioms: `pytest.raises()`, `pytest.mark.parametrize()`

### Mocking
- Mock at the boundary (e.g., mock `urlopen`, not the entire provider)
- Patch early, before instantiation
- Use descriptive mock return values

```python
@patch('src.data.providers.urlopen')
def test_provider_handles_timeout(mock_urlopen):
    mock_urlopen.side_effect = urllib.error.URLError('Timeout')
    with pytest.raises(ProviderError):
        provider.fetch_historical('AAPL', '2024-01-01', '2024-01-05')
```

---

## 7. Pythonic Idioms

### Looping & Iteration
- Use `enumerate()` instead of `range(len())`:
  ```python
  # Good
  for i, bar in enumerate(bars):
      print(i, bar.close)
  
  # Bad
  for i in range(len(bars)):
      print(i, bars[i].close)
  ```

- Use `with` for file handling (auto-closes):
  ```python
  with open('data.csv') as f:
      data = f.read()
  ```

### List Comprehensions vs Generators
- Use comprehensions when you need a list multiple times
- Use generators when iterating once (memory efficient)
  ```python
  # Comprehension: allocates full list
  result = [x * 2 for x in large_list if x > 100]
  for item in result:
      process(item)
  for item in result:  # Iterate again
      process(item)
  
  # Generator: lazy evaluation
  result = (x * 2 for x in large_list if x > 100)
  for item in result:
      process(item)
  ```

### Membership Tests
- Use `in` for sets/dicts (O(1) lookup)
- Use `in` for lists only if small or one-time
  ```python
  # Good
  symbols = {'AAPL', 'MSFT', 'NVDA'}
  if 'AAPL' in symbols:
      process()
  
  # Bad (O(n) lookup)
  symbols = ['AAPL', 'MSFT', 'NVDA']
  if 'AAPL' in symbols:
      process()
  ```

### Unpacking
- Use tuple unpacking for readability:
  ```python
  # Good
  open_price, close_price = bar.open, bar.close
  
  # Also good
  a, *middle, z = [1, 2, 3, 4, 5]  # a=1, middle=[2,3,4], z=5
  ```

### Dictionary Access
- Use `.get()` with default:
  ```python
  # Good
  value = config.get('key', 'default')
  
  # Acceptable
  if 'key' in config:
      value = config['key']
  ```

---

## 8. Avoid "Magic" / Complex Patterns

### Prohibited (Unless Exceptional Reason + Comments)
- `__getattr__`, `__setattr__` (implicit attribute magic)
- Custom metaclasses
- Monkey-patching built-ins
- `eval()`, `exec()`
- Deep recursion (use loops instead)

### Acceptable (With Documentation)
- Context managers (`__enter__`, `__exit__`)
- Descriptors (`@property`, `@staticmethod`)
- Decorators (with docstring explaining purpose)
- `*args` / `**kwargs` only if documented and necessary

---

## 9. Comments & Documentation

### Bad Comments (Avoid)
```python
i += 1  # Increment i
```

### Good Comments (Explain Why)
```python
# Skip first row; it contains headers
i = 1
```

### Inline Comments: Sparingly
```python
# Good: explains non-obvious decision
cutoff = 5 * self.atr  # 5x ATR as dynamic stop, based on Chandelier strategy

# Bad: obvious
x = 10  # Set x to 10
```

### Module & Class Docstrings: Required
```python
"""
Market data storage and retrieval layer.

Provides persistent SQLite cache + optional Parquet snapshots
to avoid redundant provider calls and improve latency.
"""
```

---

## 10. Enforcement & Automation

### Local Checks (Pre-Commit)
```bash
pre-commit install  # Set up hooks in .git/hooks
git commit -m "message"  # Hooks run auto-checks
```

### Manual Checks
```bash
# Auto-format
black src/ tests/ backtest/

# Check (don't modify)
black --check src/ tests/

# Lint
pylint src/ tests/

# Style violations
pycodestyle src/ tests/

# Type checking (optional, requires stubs)
mypy src/
```

### In CI/CD
- Run `black --check` (fail if unformatted)
- Run `pylint` with score threshold
- Run `pytest` with coverage

---

## 11. Refactoring Checklist

Before submitting a PR or marking a task complete:

- [ ] All tests pass (`pytest tests/`)
- [ ] Code is formatted (`black --check src/`)
- [ ] No lint violations (`pylint src/ --fail-under=8`)
- [ ] Type hints on all public functions
- [ ] Docstrings on all public classes/functions
- [ ] No hardcoded symbols/dates (use `config/settings.py`)
- [ ] Error messages are clear and actionable
- [ ] Private methods/attributes prefixed with `_`
- [ ] Timestamps are UTC-aware
- [ ] No "magic" without documentation

---

## 12. For LLMs Working in This Codebase

**This guide is auto-loaded by:** `CLAUDE.md` (session context)

**Tools enforce this on commit:**
- Automatic fixes: `black` (formatting)
- Warnings: `pylint`, `pycodestyle` (style, metrics)
- Cannot commit until resolved (pre-commit hook)

**For new code:** Write to this standard from the start. It's faster than refactoring later.

**Questions?** Check the relevant section above or the tool configs:
- `pyproject.toml` — Black line length, pytest paths
- `.pylintrc` — Linting rules, score thresholds
- `.pre-commit-config.yaml` — Hooks that run on commit
- `CLAUDE.md` — Session context reference

---

**Last Updated:** February 24, 2026  
**Version:** 1.0
